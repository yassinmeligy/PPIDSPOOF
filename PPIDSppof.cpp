//##################### This Code Generated By ChatGPT###########################\

#include <iostream>
#include <Windows.h>
#include <vector>
#include <tlhelp32.h>
#include <locale>
#include <codecvt>
#include "pch.h"

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cout << "Usage: " << argv[0] << " <program name> <parent name>\n";
        return 1;
    }

    std::wstring programName = std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().from_bytes(argv[1]);
    std::wstring parentName = std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().from_bytes(argv[2]);

    STARTUPINFOEXW startupInfo;
    ZeroMemory(&startupInfo, sizeof(STARTUPINFOEXW));
    startupInfo.StartupInfo.cb = sizeof(STARTUPINFOEXW);

    PROCESS_INFORMATION processInfo;
    ZeroMemory(&processInfo, sizeof(PROCESS_INFORMATION));

    std::vector<wchar_t> writableProgramName(programName.begin(), programName.end());
    writableProgramName.push_back('\0');

    LPWSTR commandLine = writableProgramName.data();

    // Obtain the process ID of the parent process
    DWORD parentProcessId = 0;
    PROCESSENTRY32W parentProcessEntry;
    parentProcessEntry.dwSize = sizeof(PROCESSENTRY32W);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Process32FirstW(snapshot, &parentProcessEntry)) {
        do {
            if (wcscmp(parentProcessEntry.szExeFile, parentName.c_str()) == 0) {
                parentProcessId = parentProcessEntry.th32ProcessID;
                break;
            }
        } while (Process32NextW(snapshot, &parentProcessEntry));
    }
    CloseHandle(snapshot);

    if (parentProcessId == 0) {
        std::cerr << "Parent process not found." << std::endl;
        return 1;
    }

    // Open the parent process with appropriate access rights
    HANDLE parentProcess = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, parentProcessId);
    if (parentProcess == NULL) {
        std::cerr << "Failed to open parent process: " << GetLastError() << std::endl;
        return 1;
    }

    // Specify the parent process handle in the extended startup information
    STARTUPINFOEXW* lpStartupInfoEx = &startupInfo;//##################### This Code Generated By ChatGPT###########################\

#include <iostream>
#include <Windows.h>
#include <vector>
#include <tlhelp32.h>
#include <locale>
#include <codecvt>
#include "pch.h"

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cout << "Usage: " << argv[0] << " <program name> <parent name>\n";
        return 1;
    }

    std::wstring programName = std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().from_bytes(argv[1]);
    std::wstring parentName = std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().from_bytes(argv[2]);

    STARTUPINFOEXW startupInfo;
    ZeroMemory(&startupInfo, sizeof(STARTUPINFOEXW));
    startupInfo.StartupInfo.cb = sizeof(STARTUPINFOEXW);

    PROCESS_INFORMATION processInfo;
    ZeroMemory(&processInfo, sizeof(PROCESS_INFORMATION));

    std::vector<wchar_t> writableProgramName(programName.begin(), programName.end());
    writableProgramName.push_back('\0');

    LPWSTR commandLine = writableProgramName.data();

    // Obtain the process ID of the parent process
    DWORD parentProcessId = 0;
    PROCESSENTRY32W parentProcessEntry;
    parentProcessEntry.dwSize = sizeof(PROCESSENTRY32W);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Process32FirstW(snapshot, &parentProcessEntry)) {
        do {
            if (wcscmp(parentProcessEntry.szExeFile, parentName.c_str()) == 0) {
                parentProcessId = parentProcessEntry.th32ProcessID;
                break;
            }
        } while (Process32NextW(snapshot, &parentProcessEntry));
    }
    CloseHandle(snapshot);

    if (parentProcessId == 0) {
        std::cerr << "Parent process not found." << std::endl;
        return 1;
    }

    // Open the parent process with appropriate access rights
    HANDLE parentProcess = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, parentProcessId);
    if (parentProcess == NULL) {
        std::cerr << "Failed to open parent process: " << GetLastError() << std::endl;
        return 1;
    }

    // Specify the parent process handle in the extended startup information
    STARTUPINFOEXW* lpStartupInfoEx = &startupInfo;
    PPROC_THREAD_ATTRIBUTE_LIST lpAttributeList = NULL;
    SIZE_T attributeListSize = 0;

    InitializeProcThreadAttributeList(NULL, 1, 0, &attributeListSize);
    lpAttributeList = reinterpret_cast<PPROC_THREAD_ATTRIBUTE_LIST>(malloc(attributeListSize));
    InitializeProcThreadAttributeList(lpAttributeList, 1, 0, &attributeListSize);
    UpdateProcThreadAttribute(lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &parentProcess, sizeof(HANDLE), NULL, NULL);
    lpStartupInfoEx->lpAttributeList = lpAttributeList;

    // Create the child process with the specified parent process
    if (!CreateProcessW(NULL, commandLine, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL,
        reinterpret_cast<LPSTARTUPINFOW>(&startupInfo), &processInfo)) {
        std::cerr << "Failed to create child process: " << GetLastError() << std::endl;
        return 1;
    }

    std::cout << "Child process started successfully!" << std::endl;

    return 0;

}

    PPROC_THREAD_ATTRIBUTE_LIST lpAttributeList = NULL;
    SIZE_T attributeListSize = 0;

    InitializeProcThreadAttributeList(NULL, 1, 0, &attributeListSize);
    lpAttributeList = reinterpret_cast<PPROC_THREAD_ATTRIBUTE_LIST>(malloc(attributeListSize));
    InitializeProcThreadAttributeList(lpAttributeList, 1, 0, &attributeListSize);
    UpdateProcThreadAttribute(lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &parentProcess, sizeof(HANDLE), NULL, NULL);
    lpStartupInfoEx->lpAttributeList = lpAttributeList;

    // Create the child process with the specified parent process
    if (!CreateProcessW(NULL, commandLine, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL,
        reinterpret_cast<LPSTARTUPINFOW>(&startupInfo), &processInfo)) {
        std::cerr << "Failed to create child process: " << GetLastError() << std::endl;
        return 1;
    }

    std::cout << "Child process started successfully!" << std::endl;

    return 0;

}
